#' Utilities for computing on region
#'
#' These functions provide ways of extracting different information based on a
#' **region**: a data frame with numeric "left" and "right" columns, each row of
#' which represents a unique finite interval (open, either type of half-open, or
#' closed). Values of "left" and "right" columns should create a "ordered" set
#' of intervals: `left[1] <= right[1] <= left[2] <= right[2] <= ...` (intervals
#' with zero width are accepted). Originally, `region_*()` functions were
#' designed to work with output of [summ_hdr()], but can be used for any data
#' frame which satisfies the definition of a region.
#'
#' @param region A data frame representing region.
#' @param x Numeric vector to be tested for being inside region.
#' @param left_closed A single logical value representing whether to treat left
#'   ends of intervals as their parts.
#' @param right_closed A single logical value representing whether to treat
#'   right ends of intervals as their parts.
#' @param f A pdqr-function.
#'
#' @details `region_is_in()` tests each value of `x` for being inside interval.
#' In other words, if there is a row for which element of `x` is between "left"
#' and "right" value (respecting `left_closed` and `right_closed` options),
#' output for that element will be `TRUE`. **Note** that for zero-width
#' intervals one of `left_closed` or `right_closed` being `TRUE` is enough to
#' accept that point as "in region".
#'
#' `region_prob()` computes total probability of region according to
#' pdqr-function `f`. If `f` has "fin" [type][meta_type()], output is computed
#' as sum of probabilities for all "x" values from ["x_tbl"
#' metadata][meta_x_tbl()] which lie inside a region (respecting `left_closed`
#' and `right_closed` options while using `region_is_in()`). If `f` has "infin"
#' type, output is computed as integral of density over a region (`*_closed`
#' options having any effect).
#'
#' `region_height()` computes "height" of a region (with respect to `f`):
#' minimum value of corresponding to `f` d-function can return based on relevant
#' points inside a region. If `f` has "fin" type, those relevant points are
#' computed as "x" values from "x_tbl" metadata which lie inside a region (if
#' there are no such points, output is 0). If `f` has "infin" type, the whole
#' intervals are used as relevant points. The notion of "height" comes from
#' [summ_hdr()] function: if `region` is `summ_hdr(f, level)` for some `level`,
#' then `region_height(region, f)` is what is called in `summ_hdr()`'s docs as
#' "target height" of HDR. That is, a maximum value of d-function for which a
#' set consisting from points at which d-function has values not less than
#' target height and total probability of the set being not less than `level`.
#'
#' @return `region_is_in()` returns a logical vector (with length equal to
#' length of `x`) representing whether certain element of `x` is inside a
#' region.
#'
#' `region_prob()` returns a single number between 0 and 1 representing total
#' probability of region.
#'
#' `region_height()` returns a single number representing a height of a region
#' with respect to `f`, i.e. minimum value that corresponding d-function can
#' return based on relevant points inside a region.
#'
#' @seealso [summ_hdr()] for computing of Highest Density Region.
#'
#' @examples
#' # Type "fin"
#' d_binom <- as_d(dbinom, size = 10, prob = 0.7)
#' hdr_fin <- summ_hdr(d_binom, level = 0.6)
#' region_is_in(hdr_fin, 0:10)
#'   # This should be not less than 0.6
#' region_prob(hdr_fin, d_binom)
#' region_height(hdr_fin, d_binom)
#'
#' # Type "infin"
#' d_norm <- as_d(dnorm)
#' hdr_infin <- summ_hdr(d_norm, level = 0.95)
#' region_is_in(hdr_infin, c(-Inf, -2, 0, 2, Inf))
#'   # This should be approximately equal to 0.95
#' region_prob(hdr_infin, d_norm)
#'   # This should be equal to `d_norm(hdr_infin[["left"]][1])`
#' region_height(hdr_infin, d_norm)
#'
#' # Usage of `*_closed` options
#' region <- data.frame(left = 1, right = 3)
#'   # Closed intervals
#' region_is_in(region, 1:3)
#'   # Open from left, closed from right
#' region_is_in(region, 1:3, left_closed = FALSE)
#'   # Closed from left, open from right
#' region_is_in(region, 1:3, right_closed = FALSE)
#'   # Open intervals
#' region_is_in(region, 1:3, left_closed = FALSE, right_closed = FALSE)
#'
#' # Handling of intervals with zero width
#' region <- data.frame(left = 1, right = 1)
#'   # If at least one of `*_closed` options is `TRUE`, 1 will be considered as
#'   # "in a region"
#' region_is_in(region, 1)
#' region_is_in(region, 1, left_closed = FALSE)
#' region_is_in(region, 1, right_closed = FALSE)
#'   # Only this will return `FALSE`
#' region_is_in(region, 1, left_closed = FALSE, right_closed = FALSE)
#'
#' @name region
NULL

#' @rdname region
#' @export
region_is_in <- function(region, x, left_closed = TRUE, right_closed = TRUE) {
  assert_region(region)
  assert_type(x, is.numeric)
  assert_type(left_closed, is_truefalse, "`TRUE` or `FALSE`")
  assert_type(right_closed, is_truefalse, "`TRUE` or `FALSE`")

  # Using `findInterval()` is safe because `region` should represent ordered
  # distinct intervals
  left_ind <- findInterval(x, region[["left"]], left.open = !left_closed)
  right_ind <- findInterval(x, region[["right"]], left.open = right_closed)

  # Inside intervals left index should be bigger than right by 1 because `x`
  # element should be more than left and less than right.
  is_inside <- left_ind == right_ind + 1

  # There are corner cases when consecutive intervals have common edge and `x`
  # has element equal to that edge. For example, for region [1; 2], [2; 3] and
  # `x` being 2 `left_ind` is 2 and `right_ind` is 0.
  is_in_left <- left_closed & (x %in% region[["left"]])
  is_in_right <- right_closed & (x %in% region[["right"]])

  is_inside | is_in_left | is_in_right
}

#' @rdname region
#' @export
region_prob <- function(region, f, left_closed = TRUE, right_closed = TRUE) {
  assert_region(region)
  assert_pdqr_fun(f)
  assert_type(left_closed, is_truefalse, "`TRUE` or `FALSE`")
  assert_type(right_closed, is_truefalse, "`TRUE` or `FALSE`")

  if (meta_type(f) == "fin") {
    x_tbl <- meta_x_tbl(f)

    x_is_in_region <- region_is_in(
      region = region, x = x_tbl[["x"]],
      left_closed = left_closed, right_closed = right_closed
    )

    sum(x_tbl[["prob"]][x_is_in_region])
  } else {
    p_f <- as_p(f)

    # Formally, this returns probability of (left, right], which is equal to
    # probability of all other three edge configurations
    sum(p_f(region[["right"]]) - p_f(region[["left"]]))
  }
}

#' @rdname region
#' @export
region_height <- function(region, f, left_closed = TRUE, right_closed = TRUE) {
  assert_region(region)
  assert_pdqr_fun(f)
  assert_type(left_closed, is_truefalse, "`TRUE` or `FALSE`")
  assert_type(right_closed, is_truefalse, "`TRUE` or `FALSE`")

  x <- meta_x_tbl(f)[["x"]]
  x_is_in_region <- region_is_in(
    region, x, left_closed = left_closed, right_closed = right_closed
  )

  # `x_probe` contains all points of interest on which minimum
  # probability/density inside region might occure
  if (meta_type(f) == "fin") {
    x_probe <- x[x_is_in_region]
  } else {
    x_probe <- c(region[["left"]], region[["right"]], x[x_is_in_region])
  }

  if (length(x_probe) == 0) {
    return(0)
  } else {
    d_vec <- as_d(f)(x_probe)

    min(d_vec)
  }
}

region_draw <- function(region, col = "blue", alpha = 0.2) {
  assert_region(region)
  assert_type(col, is_single_color, "single color")
  assert_type(alpha, is_single_number, "single number")

  # This function doesn't use more convinient `rect()` because there were
  # problems with what seemed like overflow: when setting too big `ytop`
  # rectangles were drawn downward and not upward.
  n <- nrow(region)
  x <- numeric(5*n)
  y <- numeric(5*n)
  rect_id_start <- 5*seq_len(n) - 4

  x[rect_id_start] <- region[["left"]]
  x[rect_id_start+1] <- region[["left"]]
  x[rect_id_start+2] <- region[["right"]]
  x[rect_id_start+3] <- region[["right"]]
  x[rect_id_start+4] <- NA

  y[rect_id_start] <- 0
  y[rect_id_start+1] <- 2e8
  y[rect_id_start+2] <- 2e8
  y[rect_id_start+3] <- 0
  y[rect_id_start+4] <- NA

  graphics::polygon(
    x, y, border = NA, col = grDevices::adjustcolor(col, alpha.f = alpha)
  )
}

assert_region <- function(df) {
  df_name <- paste0("`", deparse(substitute(df)), "`")

  if (!is.data.frame(df)) {
    stop_collapse(df_name, " should be a data frame.")
  }
  if (!(("left" %in% names(df)) && is.numeric(df[["left"]]) &&
        all(is.finite(df[["left"]])))) {
    stop_collapse(
      df_name, ' should have numeric column "left" with finite values.'
    )
  }
  if (!(("right" %in% names(df)) && is.numeric(df[["right"]]) &&
        all(is.finite(df[["right"]])))) {
    stop_collapse(
      df_name, ' should have numeric column "right" with finite values.'
    )
  }
  if (!all(df[["right"]] >= df[["left"]])) {
    stop_collapse(
      'In ', df_name, ' all elements of column "right" should be not less ',
      'than corresponding elements from column "left".'
    )
  }
  if (!is_region_ordered(df)) {
    stop_collapse(
      'In ', df_name, ' columns "left" and "right" should represent ordered ',
      'set of distinct intervals: left[1] <= right[1] <= left[2] <= rihgt[2] ',
      '<= ..., and there should not be duplicated intervals.'
    )
  }

  TRUE
}

is_region_ordered <- function(df) {
  # Values in "left" (`l`) and "right" (`r`) column should be ordered
  # (weakly) increasingly as: l[1] <= r[1] <= l[2] <= r[2] <= ... <= r[nrow(df)]
  comb <- alternate(df[["left"]], df[["right"]])

  # Order condition
  all(order(comb) == seq_len(2*nrow(df))) &&
    # Uniqueness condition
    !any(duplicated(df[, c("left", "right")]))
}
