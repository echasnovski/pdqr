% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/region.R
\name{region}
\alias{region}
\alias{region_is_in}
\alias{region_prob}
\alias{region_height}
\title{Utilities for computing on region}
\usage{
region_is_in(region, x, left_closed = TRUE, right_closed = TRUE)

region_prob(region, f, left_closed = TRUE, right_closed = TRUE)

region_height(region, f, left_closed = TRUE, right_closed = TRUE)
}
\arguments{
\item{region}{A data frame representing region.}

\item{x}{Numeric vector to be tested for being inside region.}

\item{left_closed}{A single logical value representing whether to treat left
ends of intervals as their parts.}

\item{right_closed}{A single logical value representing whether to treat
right ends of intervals as their parts.}

\item{f}{A pdqr-function.}
}
\value{
\code{region_is_in()} returns a logical vector (with length equal to
length of \code{x}) representing whether certain element of \code{x} is inside a
region.

\code{region_prob()} returns a single number between 0 and 1 representing total
probability of region.

\code{region_height()} returns a single number representing a height of a region
with respect to \code{f}, i.e. minimum value that corresponding d-function can
return based on relevant points inside a region.
}
\description{
These functions provide ways of extracting different information based on a
\strong{region}: a data frame with numeric "left" and "right" columns, each row of
which represents a unique finite interval (open, either type of half-open, or
closed). Values of "left" and "right" columns should create a "ordered" set
of intervals: \code{left[1] <= right[1] <= left[2] <= right[2] <= ...} (intervals
with zero width are accepted). Originally, \code{region_*()} functions were
designed to work with output of \code{\link[=summ_hdr]{summ_hdr()}}, but can be used for any data
frame which satisfies the definition of a region.
}
\details{
\code{region_is_in()} tests each value of \code{x} for being inside interval.
In other words, if there is a row for which element of \code{x} is between "left"
and "right" value (respecting \code{left_closed} and \code{right_closed} options),
output for that element will be \code{TRUE}. \strong{Note} that for zero-width
intervals one of \code{left_closed} or \code{right_closed} being \code{TRUE} is enough to
accept that point as "in region".

\code{region_prob()} computes total probability of region according to
pdqr-function \code{f}. If \code{f} has "fin" \link[=meta_type]{type}, output is computed
as sum of probabilities for all "x" values from \link[=meta_x_tbl]{"x_tbl" metadata} which lie inside a region (respecting \code{left_closed}
and \code{right_closed} options while using \code{region_is_in()}). If \code{f} has "infin"
type, output is computed as integral of density over a region (\code{*_closed}
options having any effect).

\code{region_height()} computes "height" of a region (with respect to \code{f}):
minimum value of corresponding to \code{f} d-function can return based on relevant
points inside a region. If \code{f} has "fin" type, those relevant points are
computed as "x" values from "x_tbl" metadata which lie inside a region (if
there are no such points, output is 0). If \code{f} has "infin" type, the whole
intervals are used as relevant points. The notion of "height" comes from
\code{\link[=summ_hdr]{summ_hdr()}} function: if \code{region} is \code{summ_hdr(f, level)} for some \code{level},
then \code{region_height(region, f)} is what is called in \code{summ_hdr()}'s docs as
"target height" of HDR. That is, a maximum value of d-function for which a
set consisting from points at which d-function has values not less than
target height and total probability of the set being not less than \code{level}.
}
\examples{
# Type "fin"
d_binom <- as_d(dbinom, size = 10, prob = 0.7)
hdr_fin <- summ_hdr(d_binom, level = 0.6)
region_is_in(hdr_fin, 0:10)
  # This should be not less than 0.6
region_prob(hdr_fin, d_binom)
region_height(hdr_fin, d_binom)

# Type "infin"
d_norm <- as_d(dnorm)
hdr_infin <- summ_hdr(d_norm, level = 0.95)
region_is_in(hdr_infin, c(-Inf, -2, 0, 2, Inf))
  # This should be approximately equal to 0.95
region_prob(hdr_infin, d_norm)
  # This should be equal to `d_norm(hdr_infin[["left"]][1])`
region_height(hdr_infin, d_norm)

# Usage of `*_closed` options
region <- data.frame(left = 1, right = 3)
  # Closed intervals
region_is_in(region, 1:3)
  # Open from left, closed from right
region_is_in(region, 1:3, left_closed = FALSE)
  # Closed from left, open from right
region_is_in(region, 1:3, right_closed = FALSE)
  # Open intervals
region_is_in(region, 1:3, left_closed = FALSE, right_closed = FALSE)

# Handling of intervals with zero width
region <- data.frame(left = 1, right = 1)
  # If at least one of `*_closed` options is `TRUE`, 1 will be considered as
  # "in a region"
region_is_in(region, 1)
region_is_in(region, 1, left_closed = FALSE)
region_is_in(region, 1, right_closed = FALSE)
  # Only this will return `FALSE`
region_is_in(region, 1, left_closed = FALSE, right_closed = FALSE)

}
\seealso{
\code{\link[=summ_hdr]{summ_hdr()}} for computing of Highest Density Region.
}
