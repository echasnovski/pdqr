% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group-generics.R
\name{methods-group-generic}
\alias{methods-group-generic}
\alias{Math.pdqr}
\alias{Ops.pdqr}
\alias{Summary.pdqr}
\title{Pdqr methods for S3 group generic functions}
\usage{
\method{Math}{pdqr}(x, ...)

\method{Ops}{pdqr}(e1, e2)

\method{Summary}{pdqr}(..., na.rm = FALSE)
}
\arguments{
\item{x, e1, e2}{Objects.}

\item{...}{Further arguments passed to methods.}

\item{na.rm}{Logical: should missing values be removed?}
}
\value{
All methods return pdqr-function which represents the result of
applying certain function to random variable(s) described with input
pdqr-function(s). \strong{Note} that independence of input random variables is
assumed, i.e. \code{f + f} is not the same as \code{2*f} (see Examples).
}
\description{
There are custom methods implemented for three out of four \link[base:groupGeneric]{S3 group generic functions}: \code{Math}, \code{Ops}, \code{Summary}. \strong{Note} that many
of them have random nature with an idea of generating samples from input
pdqr-functions, performing certain operation on them (results in one
generated sample from desired random variable), and creating new
pdqr-function with appropriate \link[=new-pdqr]{new_*()} function. This is done
with \code{\link[=form_trans]{form_trans()}}, so all rules for determining \link[=meta_class]{class} and
\link[=meta_type]{type} of output is taken from it.
}
\details{
Customization of method behavior may be done using mechanism of
\link[base:options]{options()}. These are the possible options:
\itemize{
\item \strong{\code{pdqr.group_gen.args_new}}. This will be used as \code{args_new} argument for
\code{form_trans()} in methods with random nature. Default is \code{list()}.
\item \strong{\code{pdqr.group_gen.n_sample}}. This will be used as \code{n_sample} argument for
\code{form_trans()} in methods with random nature. Default is 10000.
\item \strong{\code{pdqr.group_gen.repair_supp_method}}. All methods that have random
nature take care of output support by trying to "repair" it, because default
use of \code{new_*()} functions returns a slightly bigger support than range of
input sample (see Examples). Repairing is done with \code{\link[=form_resupport]{form_resupport()}} where
target support is computed separately and \code{method} argument is controlled by
this option (preferred ones are \code{"reflect"}, default, and \code{"trim"}). In most
cases output support is computed directly based on special features of
generic function. But for some difficult cases, like \code{gamma()}, \code{digamma()},
\code{lgamma()}, \code{psigamma()}, \code{^}, and \code{\%\%} it is a result of simulation (i.e.
slightly random, which slightly increases random nature of those methods).
}
}
\section{Math}{


This family of S3 generics represents mathematical functions. Most of the
methods have \strong{random nature}, except \code{abs()} and \code{sign()} which are
computed directly. Output of \code{sign()} has "fin" type with 3 "x" values: -1,
0, 1.

\strong{Note} that \code{cumsum()}, \code{cumprod()}, \code{cummmax()}, and \code{cummin()} functions
don't make much sense in these implementations: their outputs represent
random variable, sample of which is computed by applying \code{cum*()} function to
a sample, generated from input pdqr-function.
}

\section{Ops}{


This family of S3 generics represents common operators. Their input might be
a pdqr-function or single number.

A list of methods with \strong{non-random nature}:
\itemize{
\item \code{!}, \code{+}, \code{-} in case of single input, i.e. \code{!f} or \code{-f}.
\item Functions representing linear transformation, i.e. adding, subtracting,
multiplying, and dividing by a single number. For example, all \code{f + 1},
\code{2 - f} (which is actually \code{(-f) + 2}), \code{3*f} and \code{f/2} are linear
transformations, but \code{1 / f}, \code{f + g} are not.
\item Functions for comparing: \code{==}, \code{!=}, \code{<}, \code{<=}, \code{>=}, \code{>}. Their output is
\strong{boolean pdqr-function}: "fin" type function with elements being exactly 0
and 1. Probability of 0 represents probability of operator output being
false, and 1 - being true. Probability of being true is computed directly as
\strong{limit of empirical estimation from simulations} (as size of samples grows
to infinity). In other words, output is an exact number which might be
approximated by simulating two big samples of same size from input \code{e1} and
\code{e2} (one of which might be a single number), and estimating probability as
share of those pairs from samples for which comparison is true. \strong{Note}
that if at least one input has "infin" type then:
\itemize{
\item \code{==} will always have probability 0 of being true because probability
of generating a certain exact one or two numbers from continuous random
variable is zero.
\item \code{!=} will always have probability 1 of being true for the same reason
as above.
\item Pairs \code{>=} and \code{>}, \code{<=} and \code{<} will return the same input because
probability of being equal is always zero.
}
\item Logical functions \code{&} and \code{|}. They are most useful for applying to boolean
pdqr-functions (see description of functions for comparing). \code{&}'s
probability of being true is a product of those probabilities from input \code{e1}
and \code{e2}. \code{|}'s probability of being false is a product of those
probabilities from input \code{e1} and \code{e2}. \strong{Note} that probability of being
true is a probability of being equal to 1; of being false - complementary to
that.
}

All other methods are \strong{random}. For example, \code{f + f}, \code{f^g} are random.
}

\section{Summary}{


Methods for \code{all()} and \code{any()} have \strong{non-random nature}. They return a
boolean pdqr-function with the following probability of being true:
\itemize{
\item In \code{all()} - probability of \emph{all} input function being true, i.e. product
of probabilities of being true (implemented as probability of being equal to
1).
\item In \code{any()} - probability of \emph{any} input function being true, i.e.
complementary probability to product of all functions being false
(implemented as complementary probability to being true).
}

Methods for \code{sum()}, \code{prod()}, \code{min()}, \code{max()} have \strong{random nature}. They
are implemented to use vectorized version of certain generic, because
transformation function for \code{form_trans()} should be vectorized: for input
samples which all have size n it should also return sample of size n (where
each element is a transformation output for corresponding elements from input
samples). This way \code{min(f, g)} can be read as "random variable
representing minimum of \code{f} and \code{g}", etc.

\code{range()} function doesn't make sense here because it returns 2 numbers per
input and therefore can't be made vectorized. Error is thrown if it is
applied to pdqr-function.
}

\examples{
d_norm <- as_d(dnorm)
d_unif <- as_d(dunif)
d_fin <- new_d(data.frame(x = 1:4, prob = 1:4 / 10), "fin")

set.seed(101)

# Math
plot(d_norm, main = "Math methods")
  # `abs()` and `sign()` are not random
lines(abs(d_norm), col = "red")
  # All others are random
lines(cos(d_norm), col = "green")
lines(cos(d_norm), col = "blue")

  # Although here distribution shouldn't change, it changes slightly due to
  # random implementation
meta_x_tbl(d_fin)
meta_x_tbl(floor(d_fin))

# Ops
  # Single input, linear transformations, and logical are not random
d_fin > 1
!(d_fin > 1)
d_norm >= (2*d_norm+1)
  # All others are random
plot(d_norm + d_norm)
  # This is an exact reference curve
lines(as_d(dnorm, sd = sqrt(2)), col = "red")

plot(d_fin + d_norm)

plot(d_unif^d_unif)

# Summary
  # `all()` and `any()` are non-random
all(d_fin > 1, d_fin > 1)
  # Others are random
plot(max(d_norm, d_norm, d_norm))

plot(d_norm + d_norm + d_norm)
lines(sum(d_norm, d_norm, d_norm), col = "red")

# Use `options()` to control methods
plot(d_unif + d_unif)
op <- options(
  pdqr.group_gen.n_sample = 100,
  pdqr.group_gen.args_new = list(adjust = 0.5)
)
lines(d_unif + d_unif, col = "red")
  # `f + f` is different from `2*f` due to independency assumption. Also the
  # latter implemented non-randomly.
lines(2 * d_unif, col = "blue")

# Methods for generics attempt to repair support, so they are more reasonable
# to use than direct use of `form_trans()`
d_unif + d_unif
form_trans(list(d_unif, d_unif), `+`)

}
\seealso{
\link[=methods-print]{Pdqr methods for print function}.

Methods for \code{\link[=plot]{plot()}} and \code{\link[=lines]{lines()}}.

\code{\link[=summ_prob_true]{summ_prob_true()}} and \code{\link[=summ_prob_false]{summ_prob_false()}} for extracting probability from
boolean pdqr-functions.
}
